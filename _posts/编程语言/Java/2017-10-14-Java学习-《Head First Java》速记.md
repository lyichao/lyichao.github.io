---
title: Java学习-《Head First Java》速记
description: <center>看《Head First Java》这本书的同时，把一些知识点记录下来</center>
categories:
 - 编程语言
tags: Java
updated: 2018-01-22 00:00:00
---

### 什么是面向对象？

> 面向对象，这是相对面向过程来说，就比如你在开车，你所要关心的是怎么把车发
> 动起来，开上路，车就是对象，对着车，开好车就行了。至于车里面的发动机是怎
> 么做活塞运动等等一系列活动(面向过程)，你不需要关心。

### 什么是覆盖？
> 覆盖的意思是由子类重新定义继承下来的方法，以改变或延伸此方法的行为。

### random（）方法

> 随机产生0.0-1.0之间的数字

### 对象创建的存放地

> 创建对象时，对象会被存放在堆内存当中。不管对象如何创建都会放在此区域中，
> Java会根据对象的大小来分配内存空间。

### 对象的命名规则
> - 名称必须以字母、下划线（_）或$符号开头，不能用数字开头。
> - 除了第一个字符之外，后面就可以用数字。反正不要用在第一个字符就行。
> - 不能使用关键字命名。

### 没被引用的对象变量值

> 没有引用到任何对象的引用变量的值为null值。

### Getter与Setter
> - Getter：返回实力变量值
> - Setter：设定实例变量值

### 什么是封装？

> - 封装的基本原则：将实例变量标记为私有的，并提供公有的getter与setter来控制存
>   取动作。
> - Java类中的属性如果没有特别的需求，都必须声明为private的，就是只能在本类中
>   访问，如果其他类想访问，就必须通过get，set方法，这就是Java中的一大特征之
>   一：封装。从而保证安全性。
> - 如果用public（任何类都可以直接访问）修饰的话，虽然操作简单，但对数据不安全。
>   （将实例变量标记为private，将getter与setter标记为public）

### 实例变量的有默认值属性

> 实例变量永远都会有默认值。如果没有明确的赋值给实例变量，或者没有调用
> setter，实例变量还是会有值！
> （注意：局部变量没有默认值！如果在变量被初始前就要使用的话，编译器会报
> 错）

### 变量的比较

> - “==”用来判断两个对象是否引用统一对象
> - “equals（）”用来判断两个对象是否相等（像是两个String对象是否带有
>   相同的字节组合）

### indexOf的使用

>indexOf（）在找不到相符合的对象的情况下会让indexOf（）返回-1

### 继承的关系

> 次级类会继承上级类的方法。也就是说，子类会自动获得父类的功能。

### 什么是覆盖？

> 覆盖的意思是由子类重新定义继承下来的方法以改变或延伸此方法的行为。

### 子类如何调取父类？

> 通过super关键词来取用父类。

### public类和private类的继承问题

>- public类型的成员会被继承。
>- private类型的成员不会被继承。

### 子类

> - 子类是extends父类出来的。
> - 子类会继承父类所有public类型的实例变量和方法，但不会继承父类所有private类型的变量和方法。
> - 继承下来的方法可以被覆盖掉，但实例变量不能被覆盖掉。
> - 当某个方法在子类中被覆盖过，调用这个方法时会被调用到覆盖过的版本，

### 继承的意义（P182）

> - 避免了重复的程序代码
> - 定义出共同的协议。

### 覆盖的规则（P190）

> 当你要覆盖父类的方法时，你就得同意要履约。比如，这个合约表示“我没有参数且返回布尔
> 值”。因此，你所覆盖的方法就必须没有参数且返回布尔值。
>
> - 参数必须要一样，且返回类型必须要兼容
> - 不能降低方法的存取权限

### 方法的重载（P191）

> 重载的意义是两个方法的名称相同，但参数不同。所以，重载与多态毫无关系。
>
> - 返回类型可以不同
> - 布恩那个只改变返回类型
> - 可以更改存取权限

### 抽象的方法（P203）

> - 抽象的类代表此类必须要被extend过，抽象的方法代表此方法一定要被覆盖过。
> - 抽象的方法没有实体。
> - 如果你声明出一个抽象的方法，就必须将此类也标记为抽象的。你不能在非抽象类仲拥有抽
>   象方法。
> - 抽象的方法没有内容，它只是为了标记出多态而存在，这表示在继承书结构下的第一个具体
>   类必须要实现出所有的抽象方法。
> - 必须实现所有抽象的方法——表示说必须写出内容。必须以相同的方法鉴名（名称和参数）
>   和相容的返回类型创建出的非抽象得方法。

### Object类

>在Java中的所有类都是从Object这个类继承出来的。Object这个类是所有类的源头，它是所有类的
>父类。（P208）

### 栈与堆：生存空间（P236）

> - 内存中的两种区域：对象的生存空间堆（heap）和方法调用及变量的生存空间（stack）。
> - 实例变量是被声明在类而不是方法里面。
> - 局部变量和方法的参数都是被声明在方法中。
> - 当你调用一个方法是，改方法会放在调用栈的栈顶。
> - 栈顶上的方法是目前正在执行的方法。

### 什么是构造函数？

> - 构造函数是用来初始化对象的状态，也就是说设置和给对象的实例变量赋值。（P243）
> - 在创建新对象时，所有继承下来的构造函数都会被执行。（P251）
> - 在构造函数仲用super调用父类的构造函数的部分。（P251）
> - 编译器帮忙加的一定会是没有参数的版本，假使父类有多个重载版本，也只有无参数的这个版本会
>   被调用到。（P253）

### 什么是this？

> this就是个对对象本身的引用。this()只能用在构造函数中，且它必须是第一行语句！每个构造函数
> 可以选择调用super()或this()，但不能同时调用。（P256）

### 局部变量的使用范围

> 局部变量只会存活与哦在声明该变量的方法中。（P258）

### 为什么不用的对象要及时回收？

> 对象用完了就要抛弃，这样才能让垃圾回收器有东西可以回收。如果你把持着对象
> 不放，垃圾收集器也帮不了什么忙。（P260）

### 静态

> - 静态的方法不能调用非静态的变量（P277）
> - 静态的方法也不能调用非静态的方法（P278）
> - 静态变量的值对所有的实例来说都相同（P279）
> - 静态变量是共享的；
> - 同一类所有的实例共享一份静态变量；（P280）
>   - 实例变量：每一个实例一个
>   - 静态变量：每个类一个
> - 静态变量会在该类的任何对象创建之前就完成初始化；（P281）
> - 静态变量会在该类的任何静态方法执行之前就初始化；
> - 静态的final变量是常数，常数变量的名称应该要都是大写字母。（P282）、

### try/catch注意点

> 如果try或catch块有return指令，finally还是会执行！流程会跳到finally然后再回到return指令。（P327）

### 内部类使用技巧

> 内部类可以使用外部所有的方法与变量，就算是私用的也一样。内部类把存取外部类的方法和变量当作是开自家冰箱。（P376）

### 如何理解串流？

> 将串流（stream）连接起来代表来源与目的地（文件或网络端口）的连接。串流必须要连接到某处才能算是个串流。（P433）

### 序列化的使用

> 当对象被序列化时，被改对象引用的实例变量也会被序列化。且所有被引用的对象也会被序列化。（P436）

### File对象

> - File对象代表磁盘上的文件或目录的路径名称，如：/User/Kathy/Data/GameFile.txt但它并不能读取或代表文件中的数据。（P452）
>
> - 读取是以while循环来逐行进行，一直到readLine（）的结果为null为止。（P454）

### split（）

> split（）会用参数所指定的字符串把这个String拆开成两个部分。（P458）

### 在Java中以大写字母开始的东西是类。（P490）

### 为什么会发生死锁？

> 死锁会发生是因为两个线程互相持有对方正在等待的东西。（P516）

### Map

> Map中的元素实际上是两个对象：关键字和值。值可以重复，但是key不行。

### HashMap

> HashMap需要两个类型参数，关键字和值