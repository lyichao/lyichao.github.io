---
title: Android开发-自问自答
description: <center>是什么？为什么？怎么办？</center>
categories:
 - Android
tags: BUG/问题
updated: 2017-10-10 12:23:33
---

### 1.`Application`是什么？

> 答：
>
> - **每个App都有一个Application实例**：如果我们没有继承`Application`子类自定义它的话，`App`会创建一个默认的实例。
> - **Application实例拥有着与App一样长的生命周期**：在`App`开启的时候首先就会实例化它，然后才是入口的`Activity`或者`Service`等。
> - **Application与App“同生共死”**，在一个`App`的生命周期只实例化一次，所以它“天生”就是一个单例，不需要使用单例模式去实现它

### 2.`setter`、`getter`是什么？

>答：
>
>`setter`:设置值
>
>`getter`:获取值
>
>**为什么要使用`setter`和`getter`？**
>
>答：那是因为属性是`private`时，在这个类的外部是无法调用到这个类里面的属性的。所有如果要在此属性所属类的外面调用到属性的话，就要使用到`setter`和`getter`
>
>[参考链接](<https://baijiahao.baidu.com/s?id=1617744704608746204&wfr=spider&for=pc>)

### 3.枚举类是什么？

> 答：[参考链接](<https://www.wanandroid.com/blog/show/2038>)

### 4.`extend`和`implements`是什么？

>答：
>
>1. 在类的声明中，通过关键字`extends`来创建一个类的子类。一个类通过关键字`implements`声明自己使用一个或者多个接口。
>  `extends` 是继承某个类, 继承之后可以使用父类的方法, 也可以重写父类的方法; `implements` 是实现多个接口, 接口的方法一般为空的, 必须重写才能使用
>2. `extends`是继承父类，只要那个类不是声明为`final`或者那个类定义为`abstract`的就能继承，`Java`中不支持多重继承，但是可以用接口来实现，这样就要用到`implements`，继承只能继承一个类，但`implements`可以实现多个接口，用逗号分开就行了
>  比如` class A extends B implements C,D,E`

### 5.`serializable`是什么？

>答：
>
>`Serializable`是序列化的意思，表示将一个对象转换成可以存储或者可传输的状态。序列化后的对象可在网络上进行传输，也可以存储到本地。

### 6.`layout_gravity`和`gravity`是什么？

>答：
>
>`layout_gravity`：这个是针对控件本身而言，用来控制该控件在包含该控件的父控件中的位置。同样，当我们在Button按钮控件中设置`android:layout_gravity="left"`属性时，表示该Button按钮将位于界面的左部。
>
>`gravity`：这个是针对控件里的元素来说的，用来控制元素在该控件里的显示位置。例如，在一个Button按钮控件中设置如下两个属性，`android:gravity="left"`和`android:text="提交"`，这时Button上的文字“提交”将会位于Button的左部。

### 7.`context`和是什么？

>答：
>
>获取到当前对象的上下文,这个是`View`类中提供的方法，在继承了`View`的类中才可以调用，返回的是当前`View`运行在哪个`Activity Context`中。
>
>[参考链接](<https://blog.csdn.net/guolin_blog/article/details/47028975>)

### 8.`getActivity`是什么？

>答：
>
>获取当前`Activity`的实例,`getActivity()`大部分都是在`fragment`中使用到，而`fragment`需要依赖于`activity`。
>
>所有我们在`fragment`里头需要做一些动作，比如启动一个`activity`，
>就需要拿到`activity`对象才可以启动，而`fragment`对象是没有`startActivity()`方法的。

### 9.`this`是什么？

> 答：
>
> 表示当前对象；一般而言，在哪个类中调用，就是指向该对象。想表示外部类的话就得加上`外部类的类名.this`。

### 10.泛型是什么？

>答：
>
>所谓“泛型”，就是“宽泛的数据类型”，任意的数据类型。
>
>**为什么要使用泛型？**
>
>答：设想一下 , 如果我们没有泛型 , 那么我们在使用List的时候,  经常使用到的操作就是存和取 , 但是我们因为不能指定泛型 , 所以只能存入Object类型.
>
>- 存数据  `list.add(new Person());`
>   恩 , 没有多大的影响 , 转型操作让我们很舒服 , 但是取数据就没这么方便了
>- 取数据  `Person p = (Person) list.get(0)`
>   每次取出数据都要先进行强制类型转换 , 转来转去的很快你就会迷糊。所以 , 我们现在引入了泛型之后 , 对于List的操作就方便多了

### 11.反射是什么？

>答：
>
>`Java`反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为`Java`语言的反射机制（注意关键词：运行状态）
>
>[参考链接](<https://blog.csdn.net/haigand/article/details/90973683>)

### 12.单例是什么？

>答：
>
>单例是一种对象创建模式，它用于产生一个对象的具体实例，它可以确保系统中一个类只产生一个实例。
>
>**为什么使用单例？**
>
>答：
>
>- 对于频繁使用的对象，可以省略创建对象所花费的时间，这对于那些重量级的对象而言，是非常可观的一笔系统开销。
>- 由于`new`操作的次数减少，因而对系统内存的使用频率也会降低，这将减轻`GC`压力，缩短`GC`停顿时间。

### 13.`APPCompatActivity`是什么？

>答：从`Android 21`之后引入`Material Design`的设计方式，为了支持`Material Color` 、调色板、`toolbar`等各种新特性，`AppCompatActivity`就应用而生。
>
> 代替了原有的`ActionBarActivity`。在`AppCompatActivity`中，更是引入了`AppCompatDelegate`类的设计，可以在普通的`Acitivity`中使用`AppCompate`的相关特性。

### 14.`private` 、`public`、`protected`、和`default      `是什么？

>答：
>
>指类中的数据成员访问权限，具体访问权限如下：
>
>| 作用域    | 当前类 | 同一Package | 子孙类 | 其他Package |
>| :-------- | :----: | :---------: | :----: | :---------: |
>| public    |   √    |      √      |   √    |      √      |
>| protected |   √    |      √      |   √    |      ×      |
>| default   |   √    |      √      |   ×    |      ×      |
>| private   |   √    |      ×      |   ×    |      ×      |

### 15.`abstract`是什么？

>答：
>
> 用关键字abstract修饰的类称为abstract类（抽象类），如：
>
>```java
>abstract classA{}
>```
>
>用关键字abstract修饰的方法称为abstract方法（抽象方法）,如：
>
>```java
>abstract int min （int x，int y）；
>```
>
>对于abstract方法只允许声明，不允许实现（因为没有方法体）（毕竟叫抽象，当然不能实实在在的让你实现），并且不允许使用final和abstract同时修饰一个方法或者类，也不允许使用static修饰abstract方法。也就是说，abstract方法只能是实例方法，不能是类方法。
>



